# -*- coding: utf-8 -*-
"""Mushroom Classifier App

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bU6pk01ab0yy6-sSeqabn5m2AtNQb_zi
"""

import streamlit as st
from PIL import Image
import numpy as np
import tensorflow as tf
import io
import joblib
from ultralytics import YOLO

# --- Configuration ---
# Set the page configuration for the Streamlit app.
# This should be the first Streamlit command in your script.
st.set_page_config(
    page_title="Mushroom Classifier",
    page_icon="üçÑ",
    layout="wide",
    initial_sidebar_state="expanded",
)

# --- Model Loading ---

# IMPORTANT: Make sure your model files are in the same directory as this script,
# or provide the full path to the files.

@st.cache_resource
def load_cnn_model():
    """Loads the trained Keras CNN model."""
    try:
        # Replace 'your_cnn_model.h5' with the actual filename of your Keras model.
        model = tf.keras.models.load_model('mushroom_classifier_model.keras')
        return model
    except Exception as e:
        st.error(f"Error loading CNN model: {e}")
        return None

@st.cache_resource
def load_svm_model():
    """Loads the trained SVM model."""
    try:
        # Replace 'your_svm_model.joblib' with the actual filename of your SVM model.
        model = joblib.load('mushroom_svm_model.joblib')
        return model
    except Exception as e:
        st.error(f"Error loading SVM model: {e}")
        return None

@st.cache_resource
def load_yolo_model():
    """Loads the trained YOLO model from a .pt file."""
    try:
        # Replace 'your_yolo_model.pt' with the actual filename of your YOLO model.
        model = YOLO('mushroom_yolo.pt')
        return model
    except Exception as e:
        st.error(f"Error loading YOLO model: {e}")
        return None

# IMPORTANT: Define the class names your model was trained on.
# The order MUST exactly match the output of your model's prediction.
CLASS_NAMES = [
    "Agaricus xanthodermus",
    "Amanita augusta",
    "Amanita cirtina",
    "Armillaria mellea",
    "Boletus Edulis",
    "Clitocybe nuda",
    "Flammulina velutipes",
    "Hypholama lateritium",
    "Lactarius torminosus",
    "Leccinum scabrum",
]

# IMPORTANT: Define the toxicity information for each of your classes.
TOXICITY_INFO = {
    "Agaricus xanthodermus" : "Toxic",
    "Amanita augusta" : "Toxic",
    "Amanita cirtina" : "Toxic",
    "Armillaria mellea" : "Toxic",
    "Boletus Edulis" : "Toxic",
    "Clitocybe nuda" : "Safe",
    "Flammulina velutipes" : "Safe",
    "Hypholama lateritium" : "Safe",
    "Lactarius torminosus" : "Safe",
    "Leccinum scabrum" : "Safe",
}

# --- Prediction Function ---

def predict(model, image, model_type):
    """
    Preprocesses the image and returns prediction based on the model type.
    """
    # Open the image using PIL
    image = Image.open(io.BytesIO(image)).convert('RGB')

    # IMPORTANT: Change (128, 128) to your model's expected input size.
    target_size = (224, 224)
    image = image.resize(target_size)

    # Convert the image to a numpy array and normalize it
    image_array = np.array(image) / 255.0

    if model_type == 'CNN':
        # Add a batch dimension for the CNN model
        image_batch = np.expand_dims(image_array, axis=0)
        # Make a prediction
        predictions = model.predict(image_batch)
        predicted_index = np.argmax(predictions[0])
        confidence = np.max(predictions[0])
        return predicted_index, confidence

    elif model_type == 'SVM':
        # --- SVM Preprocessing ---
        # The SVM expects 8100 features, which corresponds to a 90x90 grayscale image.
        target_size = (90, 90)
        image = image.resize(target_size)
        image = image.convert('L') # Convert to grayscale
        image_array = np.array(image) / 255.0
        
        # Flatten the image array for the SVM model
        image_flattened = image_array.flatten().reshape(1, -1)
        
        # Make a prediction. The SVM model directly predicts the class name (string).
        predicted_species_name = model.predict(image_flattened)[0]
        
        # We need to find the integer index corresponding to this predicted name.
        try:
            predicted_index = CLASS_NAMES.index(predicted_species_name)
        except ValueError:
            # This is a safeguard in case the model predicts a class not in our list.
            st.error(f"Error: The model predicted a species ('{predicted_species_name}') that is not in the defined class list.")
            return None, None

        # Standard SVM .predict() doesn't give a confidence score, so we return None.
        return predicted_index, None


# --- Main Application ---
def main():
    st.title("üçÑ Mushroom Classifier & Detector")
    st.sidebar.title("Model Selection")

    model_choice = st.sidebar.radio(
        "Choose a model:",
        ('-- Select a Model --', 'CNN (Keras)', 'SVM', 'YOLO')
    )

    if model_choice == '-- Select a Model --':
        st.info("Welcome! Please select a model from the sidebar to begin.")
        st.markdown("""
        **Disclaimer:** This is for educational purposes only.
        **Do not eat any mushroom based on this classification.** Always consult an expert.
        """)

    elif model_choice in ['CNN (Keras)', 'SVM', 'YOLO']:
        model_type = model_choice.split(' ')[0] # Gets 'CNN', 'SVM', or 'YOLO'
        st.header(f"Using {model_choice} Model")

        model = None
        if model_type == 'CNN':
            model = load_cnn_model()
        elif model_type == 'SVM':
            model = load_svm_model()
        elif model_type == 'YOLO':
            model = load_yolo_model()

        if model is None:
            st.warning("The selected model could not be loaded. Please check the model file.")
            st.stop()

        uploaded_file = st.file_uploader(
            "Choose a mushroom image...",
            type=["jpg", "jpeg", "png"],
            key=f"{model_type}_uploader"
        )

        if uploaded_file is not None:
            bytes_data = uploaded_file.getvalue()
            
            if model_type == 'YOLO':
                # --- YOLO Prediction and Drawing Logic ---
                st.image(bytes_data, caption='Uploaded Image.', use_column_width=True)
                with st.spinner('Detecting mushrooms...'):
                    try:
                        # FIX: Open the image from bytes ONCE to prevent buffer issues.
                        pil_image = Image.open(io.BytesIO(bytes_data))
                        
                        # Run YOLO model on the PIL image
                        results = model(pil_image)
                        
                        # Create a copy of the image to draw on, ensuring it's in RGB mode.
                        image_to_draw_on = pil_image.copy().convert("RGB")
                        draw = ImageDraw.Draw(image_to_draw_on)
                        
                        # FIX: Gracefully load a font to prevent errors in environments
                        # where the default font is not available.
                        try:
                            font = ImageFont.load_default()
                        except IOError:
                            st.warning("Default font not found. Using a basic font for labels.")
                            font = ImageFont.load_default() # Fallback for older Pillow versions

                        detected_items = []
                        for box in results[0].boxes:
                            # Unpack box details
                            x1, y1, x2, y2 = box.xyxy[0]
                            conf = box.conf[0]
                            cls = int(box.cls[0])
                            species_name = CLASS_NAMES[cls]
                            
                            # Draw rectangle and label
                            label = f"{species_name} ({conf:.2f})"
                            draw.rectangle([x1, y1, x2, y2], outline="red", width=3)
                            draw.text((x1, y1), label, fill="red", font=font)
                            
                            detected_items.append((species_name, conf))
                        
                        st.success("Detection Complete!")
                        st.image(image_to_draw_on, caption='Processed Image with Detections.', use_column_width=True)
                        
                        st.subheader("Detected Species:")
                        if not detected_items:
                            st.info("No mushrooms were detected in the image.")
                        else:
                            for species, confidence in detected_items:
                                toxicity = TOXICITY_INFO.get(species, "Unknown")
                                st.markdown(f"- **{species}** (Confidence: {confidence:.2%}) - Toxicity: **{toxicity}**")

                    except Exception as e:
                        st.error(f"An error occurred during YOLO processing: {e}")

            else:
                # --- Classification Logic for CNN and SVM ---
                st.image(bytes_data, caption='Uploaded Image.', use_column_width=True)
                with st.spinner('Analyzing the mushroom...'):
                    predicted_index, confidence = predict_classification(model, bytes_data, model_type)
                    
                    if predicted_index is not None:
                        predicted_species = CLASS_NAMES[predicted_index]
                        toxicity = TOXICITY_INFO.get(predicted_species, "Unknown")

                        st.success("Classification Complete!")
                        st.markdown(f"### Predicted Species: **{predicted_species}**")

                        if confidence is not None:
                            st.markdown(f"### Confidence: **{confidence:.2%}**")

                        if "Poisonous" in toxicity or "Psychoactive" in toxicity:
                            st.error(f"### Toxicity: **{toxicity}** ‚ò†Ô∏è")
                        else:
                            st.success(f"### Toxicity: **{toxicity}** ‚úÖ")
# Entry point for the script
if __name__ == '__main__':
    main()
